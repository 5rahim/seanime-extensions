{
  "id": "nyaa-sukebei",
  "name": "Nyaa Sukebei",
  "description": "Nyaa provider for hentai torrents",
  "manifestURI": "https://raw.githubusercontent.com/5rahim/seanime-extensions/refs/heads/main/anime-torrent-providers/nyaa-sukebei/nyaa-sukebei.json",
  "version": "1.0.0",
  "author": "Seanime",
  "type": "anime-torrent-provider",
  "icon": "https://raw.githubusercontent.com/5rahim/hibike/main/icons/nyaa.png",
  "language": "typescript",
  "lang": "multi",
  "userConfig": {
    "requiresConfig": false,
    "version": 1,
    "fields": [
      {
        "name": "apiUrl",
        "label": "API URL",
        "type": "text",
        "default": "https://nyaa.si"
      }
    ]
  },
  "payload": "/// <reference path=\"../anime-torrent-provider.d.ts\" />\n/// <reference path=\"../../core.d.ts\" />\n\ninterface ProviderConfig {\n    baseUrl: string;\n    category: string;\n}\n\ninterface RawTorrent {\n    name: string;\n    link: string; // GUID/Page URL\n    downloadUrl: string; // .torrent file URL\n    date: string; // raw date string\n    seeders: string;\n    leechers: string;\n    downloads: string;\n    infoHash: string;\n    size: string; // formatted size string\n}\n\nclass Provider {\n    async getLatest(): Promise<AnimeTorrent[]> {\n        try {\n            const url = this.buildURL(\"\")\n            console.log(\"Sukebei: Fetching latest from \" + url)\n\n            const res = await fetch(url)\n            const rssText = await res.text()\n\n            const rawTorrents = this.parseRSSFeed(rssText)\n            const torrents = rawTorrents.map(t => this.toAnimeTorrent(t))\n\n            console.log(`Sukebei: Found ${torrents.length} latest torrents`)\n            return torrents\n        }\n        catch (error) {\n            console.error(\"Sukebei: Error fetching latest: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    async search(options: AnimeSearchOptions): Promise<AnimeTorrent[]> {\n        try {\n            // Build URL with the user's query\n            const url = this.buildURL(options.query)\n            console.log(\"Sukebei: Searching for \" + options.query)\n\n            const res = await fetch(url)\n            const rssText = await res.text()\n\n            const rawTorrents = this.parseRSSFeed(rssText)\n            const torrents = rawTorrents.map(t => this.toAnimeTorrent(t))\n\n            console.log(`Sukebei: Found ${torrents.length} torrents for query`)\n            return torrents\n        }\n        catch (error) {\n            console.error(\"Sukebei: Error searching: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    async smartSearch(options: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {\n        return []\n    }\n\n    async getTorrentInfoHash(torrent: AnimeTorrent): Promise<string> {\n        return torrent.infoHash || \"\"\n    }\n\n    async getTorrentMagnetLink(torrent: AnimeTorrent): Promise<string> {\n        try {\n            const res = await fetch(torrent.link)\n            const html = await res.text()\n            const $ = LoadDoc(html)\n\n            let magnetLink = \"\"\n\n            // Search for the magnet link\n            $(\"a.card-footer-item, a[href^=\\\"magnet:\\\"]\").each((i: number, el) => {\n                const href = el.attr(\"href\")\n                if (href && href.startsWith(\"magnet:\")) {\n                    magnetLink = href\n                    return false // Break the loop\n                }\n            })\n\n            if (!magnetLink) {\n                throw new Error(\"Magnet link not found on page\")\n            }\n\n            return magnetLink\n        }\n        catch (error) {\n            console.error(\"Sukebei: Error fetching magnet link: \" + (error as Error).message)\n            throw new Error(\"Could not fetch magnet link for: \" + torrent.name)\n        }\n    }\n\n    getSettings(): AnimeProviderSettings {\n        return {\n            canSmartSearch: false,\n            smartSearchFilters: [],\n            supportsAdult: true,\n            type: \"special\",\n        }\n    }\n\n    private getProviderSettings(): ProviderConfig {\n        let url: string = $getUserPreference(\"apiUrl\") || \"sukebei.nyaa.si\"\n\n        if (!url.startsWith(\"http\")) {\n            url = \"https://\" + url\n        }\n\n        return {\n            baseUrl: url.replace(/\\/$/, \"\"),\n            category: \"1_1\",\n        }\n    }\n\n    private buildURL(query: string, sortBy: string = \"seeders\"): string {\n        const { baseUrl, category } = this.getProviderSettings()\n\n        const queryString = `page=rss&q=${encodeURIComponent(query)}&c=${category}&f=0&s=${sortBy}&o=desc`\n        return `${baseUrl}/?${queryString}`\n    }\n\n    private parseRSSFeed(rssText: string): RawTorrent[] {\n        const torrents: RawTorrent[] = []\n\n        // Helper to extract content between XML tags\n        const getTagContent = (xml: string, tag: string): string => {\n            const regex = new RegExp(`<${tag}[^>]*>([^<]*)</${tag}>`)\n            const match = xml.match(regex)\n            return match ? match[1].trim() : \"\"\n        }\n\n        // Helper to extract content from nyaa namespace tags\n        const getNyaaTagContent = (xml: string, tag: string): string => {\n            const regex = new RegExp(`<nyaa:${tag}[^>]*>([^<]*)</nyaa:${tag}>`)\n            const match = xml.match(regex)\n            return match ? match[1].trim() : \"\"\n        }\n\n        // Split XML into items\n        const itemRegex = /<item>([\\s\\S]*?)<\\/item>/g\n        let match\n\n        while ((match = itemRegex.exec(rssText)) !== null) {\n            const itemXml = match[1]\n\n            const title = getTagContent(itemXml, \"title\")\n            const downloadUrl = getTagContent(itemXml, \"link\") // .torrent file URL\n            const link = getTagContent(itemXml, \"guid\")      // Page URL\n            const pubDate = getTagContent(itemXml, \"pubDate\")\n            const seeders = getNyaaTagContent(itemXml, \"seeders\")\n            const leechers = getNyaaTagContent(itemXml, \"leechers\")\n            const downloads = getNyaaTagContent(itemXml, \"downloads\")\n            const infoHash = getNyaaTagContent(itemXml, \"infoHash\")\n            const size = getNyaaTagContent(itemXml, \"size\")\n\n            const torrent: RawTorrent = {\n                name: title,\n                link: link,\n                downloadUrl: downloadUrl,\n                date: pubDate,\n                seeders: seeders,\n                leechers: leechers,\n                downloads: downloads,\n                infoHash: infoHash,\n                size: size,\n            }\n\n            torrents.push(torrent)\n        }\n\n        return torrents\n    }\n\n    private toAnimeTorrent(t: RawTorrent): AnimeTorrent {\n        const metadata = $habari.parse(t.name)\n\n        const seeders = parseInt(t.seeders) || 0\n        const leechers = parseInt(t.leechers) || 0\n        const downloads = parseInt(t.downloads) || 0\n\n        let formattedDate = \"\"\n        try {\n            const parsedDate = new Date(t.date)\n            if (!isNaN(parsedDate.getTime())) {\n                formattedDate = parsedDate.toISOString()\n            }\n        }\n        catch (e) {\n            console.warn(\"Sukebei: Failed to parse date: \" + t.date)\n        }\n\n        let sizeInBytes = 0\n        const sizeMatch = t.size.match(/([\\d.]+)\\s*([KMGT]?i?B)/i)\n        if (sizeMatch) {\n            const size = parseFloat(sizeMatch[1])\n            const unit = sizeMatch[2].toUpperCase()\n            if (unit.endsWith(\"IB\")) {\n                if (unit.startsWith(\"M\")) sizeInBytes = size * Math.pow(1024, 2)\n                else if (unit.startsWith(\"G\")) sizeInBytes = size * Math.pow(1024, 3)\n                else if (unit.startsWith(\"T\")) sizeInBytes = size * Math.pow(1024, 4)\n                else sizeInBytes = size * 1024\n            } else {\n                if (unit.startsWith(\"M\")) sizeInBytes = size * Math.pow(1000, 2)\n                else if (unit.startsWith(\"G\")) sizeInBytes = size * Math.pow(1000, 3)\n                else if (unit.startsWith(\"T\")) sizeInBytes = size * Math.pow(1000, 4)\n                else sizeInBytes = size * 1000\n            }\n        }\n\n        let episode = -1\n        if (metadata.episode_number && metadata.episode_number.length >= 1) {\n            episode = parseInt(metadata.episode_number[0]) || -1\n        }\n\n        let isBatchByGuess = false\n        if (metadata.episode_number && metadata.episode_number.length > 1) {\n            isBatchByGuess = true\n        }\n        if (/\\b(batch|complete|collection|seasons?|parts?)\\b/i.test(t.name)) {\n            isBatchByGuess = true\n        }\n\n        if (isBatchByGuess) {\n            episode = -1\n        }\n\n        return {\n            name: t.name,\n            date: formattedDate,\n            size: Math.round(sizeInBytes),\n            formattedSize: t.size,\n            seeders: seeders,\n            leechers: leechers,\n            downloadCount: downloads,\n            link: t.link,\n            downloadUrl: t.downloadUrl,\n            infoHash: t.infoHash,\n            magnetLink: \"\",\n            resolution: metadata.video_resolution || \"\",\n            isBatch: isBatchByGuess,\n            episodeNumber: episode,\n            releaseGroup: metadata.release_group || \"\",\n            isBestRelease: false,\n            confirmed: false,\n        }\n    }\n\n}\n"
}
