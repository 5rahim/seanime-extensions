{
  "id": "animetosho",
  "name": "Animetosho",
  "description": "Animetosho provider for english-translated torrents",
  "manifestURI": "https://raw.githubusercontent.com/5rahim/seanime-extensions/refs/heads/main/anime-torrent-providers/animetosho/animetosho.json",
  "version": "1.0.0",
  "author": "Seanime",
  "type": "anime-torrent-provider",
  "icon": "https://raw.githubusercontent.com/5rahim/hibike/main/icons/animetosho.png",
  "language": "typescript",
  "lang": "multi",
  "userConfig": {
    "requiresConfig": false,
    "version": 1,
    "fields": [
      {
        "name": "apiUrl",
        "label": "API URL",
        "type": "text",
        "default": "https://feed.animetosho.org/json"
      }
    ]
  },
  "payload": "/// <reference path=\"../anime-torrent-provider.d.ts\" />\n/// <reference path=\"../../core.d.ts\" />\n\ninterface AnimeToshoTorrent {\n    id: number;\n    title: string;\n    link: string;\n    timestamp: number;\n    status: string;\n    tosho_id?: number;\n    nyaa_id?: number;\n    nyaa_subdom?: any;\n    anidex_id?: number;\n    torrent_url: string;\n    info_hash: string;\n    info_hash_v2?: string;\n    magnet_uri: string;\n    seeders: number;\n    leechers: number;\n    torrent_download_count: number;\n    tracker_updated?: any;\n    nzb_url?: string;\n    total_size: number;\n    num_files: number;\n    anidb_aid: number;\n    anidb_eid: number;\n    anidb_fid: number;\n    article_url: string;\n    article_title: string;\n    website_url: string;\n}\n\nclass Provider {\n    private jsonFeedUrl = \"https://feed.animetosho.org/json\"\n\n    public getSettings(): AnimeProviderSettings {\n        return {\n            type: \"main\",\n            canSmartSearch: true,\n            smartSearchFilters: [\"batch\", \"episodeNumber\", \"resolution\"],\n            supportsAdult: false,\n        }\n    }\n\n    private getJsonFeedUrl() {\n        let url = $getUserPreference(\"apiUrl\") || this.jsonFeedUrl\n        if (url.endsWith(\"/\")) url = url.slice(0, -1)\n        if(!url.startsWith(\"http\")) url = \"https://\" + url\n        return url\n    }\n\n    public async getLatest(): Promise<AnimeTorrent[]> {\n        try {\n            console.log(\"AnimeTosho: Fetching latest torrents\")\n            const url = this.getJsonFeedUrl() + \"?q=\"\n            const torrents = await this.fetchTorrents(url)\n            return this.torrentSliceToAnimeTorrentSlice(torrents, false, null)\n        }\n        catch (error) {\n            console.error(\"AnimeTosho: Error fetching latest: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    public async search(options: AnimeSearchOptions): Promise<AnimeTorrent[]> {\n        try {\n            console.log(`AnimeTosho: Searching for \"${options.query}\"`)\n            const query = this.sanitizeTitle(options.query)\n            const url = `${this.getJsonFeedUrl()}?q=${encodeURIComponent(query)}`\n            const torrents = await this.fetchTorrents(url)\n            return this.torrentSliceToAnimeTorrentSlice(torrents, false, options.media)\n        }\n        catch (error) {\n            console.error(\"AnimeTosho: Error searching: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    public async smartSearch(options: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {\n        try {\n            if (options.batch) {\n                console.log(\"AnimeTosho: Smart searching for batches...\")\n                return this.smartSearchBatch(options)\n            }\n            console.log(`AnimeTosho: Smart searching for episode ${options.episodeNumber}...`)\n            return this.smartSearchSingleEpisode(options)\n        }\n        catch (error) {\n            console.error(\"AnimeTosho: Error in smart search: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    private async smartSearchBatch(options: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {\n        let atTorrents: AnimeToshoTorrent[] = []\n        let foundByID = false\n        const media = options.media\n\n        const isMovieOrSingle = media.format === \"MOVIE\" || media.episodeCount === 1\n\n        if (options.anidbAID && options.anidbAID > 0) {\n            console.log(`AnimeTosho: Searching batches by AID ${options.anidbAID}`)\n            try {\n                const torrents = await this.searchByAID(options.anidbAID, options.resolution || \"\")\n\n                // If it's a movie/single-ep, all torrents are considered \"batches\"\n                if (isMovieOrSingle) {\n                    atTorrents = torrents\n                } else {\n                    // Otherwise, filter for actual batches (multi-file)\n                    const batchTorrents = torrents.filter(t => t.num_files > 1)\n                    // If we found batches, use them. If not, use all torrents (e.g., for OVAs released as single files)\n                    atTorrents = batchTorrents.length > 0 ? batchTorrents : torrents\n                }\n\n                if (atTorrents.length > 0) {\n                    foundByID = true\n                }\n            }\n            catch (e) {\n                console.warn(\"AnimeTosho: searchByAID failed: \" + (e as Error).message)\n            }\n        }\n\n        if (foundByID) {\n            console.log(`AnimeTosho: Found ${atTorrents.length} batches by AID`)\n            return this.torrentSliceToAnimeTorrentSlice(atTorrents, true, media)\n        }\n\n        // Fallback: Search by query\n        console.log(\"AnimeTosho: Searching batches by query\")\n        const queries = this.buildSmartSearchQueries(options)\n        let allTorrents: AnimeToshoTorrent[] = []\n\n        const searchPromises = queries.map(query => {\n            const url = `${this.getJsonFeedUrl()}?only_tor=1&q=${encodeURIComponent(query)}&order=size-d`\n            return this.fetchTorrents(url)\n        })\n\n        try {\n            const results = await Promise.all(searchPromises)\n            allTorrents = results.flat()\n        }\n        catch (error) {\n            console.error(\"AnimeTosho: Batch query search failed: \" + (error as Error).message)\n            return []\n        }\n\n        // Filter out single-file torrents unless it's a movie/single-ep\n        allTorrents = allTorrents.filter(t => isMovieOrSingle || t.num_files > 1)\n\n        // Convert and remove duplicates\n        const animeTorrents = this.torrentSliceToAnimeTorrentSlice(allTorrents, false, media)\n        const uniqueTorrents = [...new Map(animeTorrents.map(t => [t.link, t])).values()]\n\n        console.log(`AnimeTosho: Found ${uniqueTorrents.length} batches by query`)\n        return uniqueTorrents\n    }\n\n    private async smartSearchSingleEpisode(options: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {\n        let atTorrents: AnimeToshoTorrent[] = []\n        let foundByID = false\n        const media = options.media\n\n        const isMovieOrSingle = media.format === \"MOVIE\" || media.episodeCount === 1\n\n        if (options.anidbEID && options.anidbEID > 0) {\n            console.log(`AnimeTosho: Searching episode by EID ${options.anidbEID}`)\n            try {\n                const torrents = await this.searchByEID(options.anidbEID, options.resolution || \"\")\n                // Filter for single-file torrents\n                atTorrents = torrents.filter(t => t.num_files === 1)\n\n                if (atTorrents.length > 0) {\n                    foundByID = true\n                }\n            }\n            catch (e) {\n                console.warn(\"AnimeTosho: searchByEID failed: \" + (e as Error).message)\n            }\n        }\n\n        if (foundByID) {\n            console.log(`AnimeTosho: Found ${atTorrents.length} episodes by EID`)\n            return this.torrentSliceToAnimeTorrentSlice(atTorrents, true, media)\n        }\n\n        // Fallback: Search by query\n        console.log(\"AnimeTosho: Searching episode by query\")\n        const queries = this.buildSmartSearchQueries(options)\n        let allTorrents: AnimeToshoTorrent[] = []\n\n        const searchPromises = queries.map(query => {\n            const url = `${this.getJsonFeedUrl()}?only_tor=1&q=${encodeURIComponent(query)}&qx=1`\n            return this.fetchTorrents(url)\n        })\n\n        try {\n            const results = await Promise.all(searchPromises)\n            allTorrents = results.flat()\n        }\n        catch (error) {\n            console.error(\"AnimeTosho: Episode query search failed: \" + (error as Error).message)\n            return []\n        }\n\n        // Filter for single-file torrents, unless it's a movie (which might be multi-file)\n        allTorrents = allTorrents.filter(t => isMovieOrSingle || t.num_files === 1)\n\n        // Convert and remove duplicates\n        const animeTorrents = this.torrentSliceToAnimeTorrentSlice(allTorrents, false, media)\n        const uniqueTorrents = [...new Map(animeTorrents.map(t => [t.link, t])).values()]\n\n        console.log(`AnimeTosho: Found ${uniqueTorrents.length} episodes by query`)\n        return uniqueTorrents\n    }\n\n    public async getTorrentInfoHash(torrent: AnimeTorrent): Promise<string> {\n        // InfoHash is provided directly by the API\n        return torrent.infoHash || \"\"\n    }\n\n    public async getTorrentMagnetLink(torrent: AnimeTorrent): Promise<string> {\n        // MagnetLink is provided directly by the API\n        return torrent.magnetLink || \"\"\n    }\n\n    //+ --------------------------------------------------------------------------------------------------\n    // Helpers\n    //+ --------------------------------------------------------------------------------------------------\n\n    private async fetchTorrents(url: string): Promise<AnimeToshoTorrent[]> {\n        console.log(`AnimeTosho: Fetching from ${url}`)\n\n        const res = await fetch(url)\n        if (!res.ok) {\n            throw new Error(`Failed to fetch torrents: ${res.status} ${res.statusText}`)\n        }\n\n        const torrents = await res.json() as AnimeToshoTorrent[]\n\n        // Clean up impossibly high seeder/leecher counts\n        return torrents.map(t => {\n            if (t.seeders > 100000) t.seeders = 0\n            if (t.leechers > 100000) t.leechers = 0\n            return t\n        })\n    }\n\n    private searchByAID(aid: number, quality: string): Promise<AnimeToshoTorrent[]> {\n        const q = encodeURIComponent(this.formatQuality(quality))\n        const query = `?order=size-d&aid=${aid}&q=${q}`\n        return this.fetchTorrents(this.getJsonFeedUrl() + query)\n    }\n\n    private searchByEID(eid: number, quality: string): Promise<AnimeToshoTorrent[]> {\n        const q = encodeURIComponent(this.formatQuality(quality))\n        const query = `?eid=${eid}&q=${q}`\n        return this.fetchTorrents(this.getJsonFeedUrl() + query)\n    }\n\n    private buildSmartSearchQueries(opts: AnimeSmartSearchOptions): string[] {\n        const { media, batch, episodeNumber, resolution } = opts\n        const hasSingleEpisode = media.episodeCount === 1 || media.format === \"MOVIE\"\n\n        let queryStr: string[] = []\n        const allTitles = this.getAllTitles(media)\n\n        if (hasSingleEpisode) {\n            let str = \"\"\n            // 1. Build a query string\n            const qTitles = `(${allTitles.map(t => this.sanitizeTitle(t)).join(\" | \")})`\n            str += qTitles\n\n            // 2. Add resolution\n            if (resolution) {\n                str += \" \" + resolution\n            }\n            queryStr = [str]\n\n        } else {\n            if (!batch) { // Single episode search\n                const qTitles = this.buildTitleString(opts)\n                const qEpisodes = this.buildEpisodeString(opts)\n\n                let str = \"\"\n                // 1. Add titles\n                str += qTitles\n                // 2. Add episodes\n                if (qEpisodes) {\n                    str += \" \" + qEpisodes\n                }\n                // 3. Add resolution\n                if (resolution) {\n                    str += \" \" + resolution\n                }\n\n                queryStr.push(str)\n\n                // If we can also search for absolute episodes\n                if (media.absoluteSeasonOffset && media.absoluteSeasonOffset > 0) {\n                    const metadata = $habari.parse(media.romajiTitle || \"\")\n                    let absoluteQueryStr = metadata.title || \"\"\n\n                    const ep = episodeNumber + media.absoluteSeasonOffset\n                    absoluteQueryStr += ` (\"${ep}\"|\"e${ep}\"|\"ep${ep}\")`\n\n                    if (resolution) {\n                        absoluteQueryStr += \" \" + resolution\n                    }\n                    // Combine original query with absolute query\n                    queryStr = [`(${absoluteQueryStr}) | (${str})`]\n                }\n\n            } else { // Batch search\n                let str = `(${media.romajiTitle})`\n                if (media.englishTitle) {\n                    str = `(${media.romajiTitle} | ${media.englishTitle})`\n                }\n                str += \" \" + this.buildBatchGroup(media)\n                if (resolution) {\n                    str += \" \" + resolution\n                }\n                queryStr = [str]\n            }\n        }\n\n        // Add \"-S0\" variant for each query (as in Go code)\n        const finalQueries: string[] = []\n        for (const q of queryStr) {\n            finalQueries.push(q)\n            finalQueries.push(q + \" -S0\")\n        }\n\n        return finalQueries\n    }\n\n    private formatQuality(quality: string): string {\n        if (!quality) return \"\"\n        return quality.replace(/p$/i, \"\")\n    }\n\n    private sanitizeTitle(t: string): string {\n        t = t.replace(/-/g, \" \") // Replace hyphens with spaces\n        t = t.replace(/[^a-zA-Z0-9\\s]/g, \"\") // Remove non-alphanumeric/space chars\n        t = t.replace(/\\s+/g, \" \") // Trim large spaces\n        return t.trim()\n    }\n\n    private getAllTitles(media: AnimeSmartSearchOptions[\"media\"]): string[] {\n        return [\n            media.romajiTitle,\n            media.englishTitle,\n            ...(media.synonyms || []),\n        ].filter(Boolean) as string[] // Filter out null/undefined/empty strings\n    }\n\n    private zeropad(v: number | string): string {\n        return String(v).padStart(2, \"0\")\n    }\n\n    private buildEpisodeString(opts: AnimeSmartSearchOptions): string {\n        if (opts.episodeNumber === -1) return \"\"\n        const pEp = this.zeropad(opts.episodeNumber)\n        // e.g. (\"01\"|\"e1\") -S0\n        return `(\"${pEp}\"|\"e${opts.episodeNumber}\") -S0`\n    }\n\n    private buildBatchGroup(media: AnimeSmartSearchOptions[\"media\"]): string {\n        const epCount = media.episodeCount || 0\n        const parts = [\n            `\"${this.zeropad(1)} - ${this.zeropad(epCount)}\"`,\n            `\"${this.zeropad(1)} ~ ${this.zeropad(epCount)}\"`,\n            `\"Batch\"`,\n            `\"Complete\"`,\n            `\"+ OVA\"`,\n            `\"+ Specials\"`,\n            `\"+ Special\"`,\n            `\"Seasons\"`,\n            `\"Parts\"`,\n        ]\n        return `(${parts.join(\"|\")})`\n    }\n\n    private extractSeasonNumber(title: string): [number, string] {\n        const match = title.match(/\\b(season|s)\\s*(\\d{1,2})\\b/i)\n        if (match && match[2]) {\n            const cleanTitle = title.replace(match[0], \"\").trim()\n            return [parseInt(match[2]), cleanTitle]\n        }\n        return [0, title]\n    }\n\n    private buildTitleString(opts: AnimeSmartSearchOptions): string {\n        const media = opts.media\n        const romTitle = this.sanitizeTitle(media.romajiTitle || \"\")\n        const engTitle = this.sanitizeTitle(media.englishTitle || \"\")\n\n        let season = 0\n        let titles: string[] = []\n\n        // create titles by extracting season/part info\n        this.getAllTitles(media).forEach(title => {\n            const [s, cTitle] = this.extractSeasonNumber(title)\n            if (s !== 0) season = s\n            if (cTitle) titles.push(this.sanitizeTitle(cTitle))\n        })\n\n        // Check season from synonyms, only update season if it's still 0\n        if (season === 0) {\n            (media.synonyms || []).forEach(synonym => {\n                const [s, _] = this.extractSeasonNumber(synonym)\n                if (s !== 0) season = s\n            })\n        }\n\n        // add romaji and english titles to the title list\n        titles.push(romTitle)\n        if (engTitle) titles.push(engTitle)\n\n        // convert III and II to season\n        if (season === 0) {\n            if (/\\siii\\b/i.test(romTitle) || (engTitle && /\\siii\\b/i.test(engTitle))) season = 3\n            else if (/\\sii\\b/i.test(romTitle) || (engTitle && /\\sii\\b/i.test(engTitle))) season = 2\n        }\n\n        // also, split titles by colon\n        [romTitle, engTitle].filter(Boolean).forEach(title => {\n            const split = title.split(\":\")\n            if (split.length > 1 && split[0].length > 8) {\n                titles.push(split[0])\n            }\n        })\n\n        // clean titles\n        titles = titles.map(title => {\n            let clean = title.replace(/:/g, \" \").replace(/-/g, \" \").trim()\n            clean = clean.replace(/\\s+/g, \" \").toLowerCase()\n            if (season !== 0) {\n                clean = clean.replace(/\\siii\\b/gi, \"\").replace(/\\sii\\b/gi, \"\")\n            }\n            return clean.trim()\n        })\n\n        titles = [...new Set(titles.filter(Boolean))] // Unique, non-empty titles\n\n        let shortestTitle = titles.reduce((shortest, current) =>\n            current.length < shortest.length ? current : shortest, titles[0] || \"\")\n\n        // Season part\n        let seasonBuff = \"\"\n        if (season > 0) {\n            const pS = this.zeropad(season)\n            seasonBuff = [\n                `\"${shortestTitle} season ${season}\"`,\n                `\"${shortestTitle} season ${pS}\"`,\n                `\"${shortestTitle} s${season}\"`,\n                `\"${shortestTitle} s${pS}\"`,\n            ].join(\" | \")\n        }\n\n        let qTitles = `(${titles.map(t => `\"${t}\"`).join(\" | \")}`\n        if (seasonBuff) {\n            qTitles += ` | ${seasonBuff}`\n        }\n        qTitles += \")\"\n\n        return qTitles\n    }\n\n    private torrentSliceToAnimeTorrentSlice(torrents: AnimeToshoTorrent[],\n        confirmed: boolean,\n        media: AnimeSmartSearchOptions[\"media\"] | null,\n    ): AnimeTorrent[] {\n        return torrents.map(torrent => {\n            const t = this.toAnimeTorrent(torrent, media)\n            t.confirmed = confirmed\n            return t\n        })\n    }\n\n    private toAnimeTorrent(t: AnimeToshoTorrent, media: AnimeSmartSearchOptions[\"media\"] | null): AnimeTorrent {\n        const metadata = $habari.parse(t.title)\n\n        // Convert UNIX timestamp to ISO string\n        const formattedDate = new Date(t.timestamp * 1000).toISOString()\n\n        const isBatch = t.num_files > 1\n        let episode = -1\n\n        if (metadata.episode_number && metadata.episode_number.length === 1) {\n            episode = parseInt(metadata.episode_number[0]) || -1\n        }\n\n        // Force set episode number to 1 if it's a movie or single-episode and the torrent isn't a batch\n        if (!isBatch && episode === -1 && media && (media.episodeCount === 1 || media.format === \"MOVIE\")) {\n            episode = 1\n        }\n\n        // If it's a batch, don't assign an episode number\n        if (isBatch) {\n            episode = -1\n        }\n\n        return {\n            name: t.title,\n            date: formattedDate,\n            size: t.total_size,\n            formattedSize: this.bytesToHuman(t.total_size),\n            seeders: t.seeders,\n            leechers: t.leechers,\n            downloadCount: t.torrent_download_count,\n            link: t.link,\n            downloadUrl: t.torrent_url,\n            magnetLink: t.magnet_uri,\n            infoHash: t.info_hash,\n            resolution: metadata.video_resolution || \"\",\n            isBatch: isBatch,\n            episodeNumber: episode,\n            releaseGroup: metadata.release_group || \"\",\n            isBestRelease: false,\n            confirmed: false,     // Will be set in torrentSliceToAnimeTorrentSlice\n        }\n    }\n\n    private bytesToHuman(bytes: number): string {\n        if (bytes === 0) return \"0 Bytes\"\n        const k = 1024\n        const sizes = [\"Bytes\", \"KiB\", \"MiB\", \"GiB\", \"TiB\"]\n        const i = Math.floor(Math.log(bytes) / Math.log(k))\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i]\n    }\n}\n"
}
