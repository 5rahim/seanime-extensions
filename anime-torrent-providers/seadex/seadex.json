{
  "id": "seadex",
  "name": "SeaDex",
  "description": "SeaDex provider for high quality torrents",
  "manifestURI": "https://raw.githubusercontent.com/5rahim/seanime-extensions/refs/heads/main/anime-torrent-providers/seadex/seadex.json",
  "version": "1.0.2",
  "author": "Seanime",
  "type": "anime-torrent-provider",
  "icon": "https://raw.githubusercontent.com/5rahim/hibike/main/icons/seadex.png",
  "language": "typescript",
  "lang": "multi",
  "userConfig": {
    "requiresConfig": false,
    "version": 1,
    "fields": [
      {
        "name": "apiUrl",
        "label": "API URL",
        "type": "text",
        "default": "https://releases.moe/api/collections/entries/records"
      }
    ]
  },
  "payload": "/// <reference path=\"../anime-torrent-provider.d.ts\" />\n/// <reference path=\"../../core.d.ts\" />\n\ninterface SeaDexTorrent {\n    name: string;\n    date: string;\n    size: number;\n    link: string;\n    infoHash: string;\n    releaseGroup?: string;\n}\n\ninterface TrFile {\n    length: number;\n    path: string;\n}\n\ninterface Tr {\n    id: string;\n    collectionId: string;\n    collectionName: string;\n    created: string;\n    updated: string;\n    entry: string;\n    url: string;\n    infoHash: string;\n    releaseGroup: string;\n    source: string;\n    tracker: string;\n    type: string;\n    files: TrFile[];\n    dualAudio: boolean;\n}\n\ninterface ExpandData {\n    trs: Tr[];\n}\n\ninterface RecordItem {\n    id: string;\n    collectionId: string;\n    collectionName: string;\n    created: string;\n    updated: string;\n    alID: number;\n    title: string;\n    expand: ExpandData;\n}\n\ninterface RecordsResponse {\n    page: number;\n    perPage: number;\n    totalItems: number;\n    totalPages: number;\n    items: RecordItem[];\n}\n\nclass Provider {\n    defaultUri = \"https://releases.moe/api/collections/entries/records\"\n\n    public getSettings(): AnimeProviderSettings {\n        return {\n            type: \"special\",\n            canSmartSearch: true, // Allowed for previews\n            supportsAdult: false,\n            smartSearchFilters: [],\n        }\n    }\n\n    public async getLatest(): Promise<AnimeTorrent[]> {\n        return []\n    }\n\n    public async search(options: AnimeSearchOptions): Promise<AnimeTorrent[]> {\n        return this.findTorrents(options.media)\n    }\n\n    public async smartSearch(options: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {\n        return this.findTorrents(options.media)\n    }\n\n    private async findTorrents(media: AnimeSearchOptions[\"media\"]): Promise<AnimeTorrent[]> {\n        if (!media || !media.id) {\n            console.log(\"SeaDex: Media ID is missing, cannot search.\")\n            return []\n        }\n\n        try {\n            const title = media.romajiTitle || media.englishTitle || \"Unknown Title\"\n            // Call the internal fetchTorrents method\n            const seadexTorrents = await this.fetchTorrents(media.id, title)\n\n            // Concurrently scrape and convert all torrents\n            const promises = seadexTorrents.map(t => this.toAnimeTorrent(t))\n            return await Promise.all(promises)\n        }\n        catch (error) {\n            console.error(\"SeaDex: Error in findTorrents: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    public async getTorrentInfoHash(torrent: AnimeTorrent): Promise<string> {\n        return torrent.infoHash || \"\"\n    }\n\n    public async getTorrentMagnetLink(torrent: AnimeTorrent): Promise<string> {\n        try {\n            const res = await fetch(torrent.link)\n            const html = await res.text()\n            const $ = LoadDoc(html)\n\n            let magnetLink = \"\"\n\n            $(\"a.card-footer-item, a[href^=\\\"magnet:\\\"]\").each((i: number, el) => {\n                const href = el.attr(\"href\")\n                if (href && href.startsWith(\"magnet:\")) {\n                    magnetLink = href\n                    return false // Break the loop\n                }\n            })\n\n            if (!magnetLink) {\n                throw new Error(\"Magnet link not found on page\")\n            }\n\n            return magnetLink\n        }\n        catch (error) {\n            console.error(\"SeaDex: Error fetching magnet link: \" + (error as Error).message)\n            throw new Error(\"Could not fetch magnet link for: \" + torrent.name)\n        }\n    }\n\n    private getUri(): string {\n        try {\n            const customUrl = $getUserPreference(\"apiUrl\")\n            if (customUrl) {\n                return customUrl\n            }\n        }\n        catch (e) {\n        }\n        return this.defaultUri\n    }\n\n    private async fetchTorrents(mediaId: number, title: string): Promise<SeaDexTorrent[]> {\n        let records: RecordItem[]\n        try {\n            records = await this.fetchRecords(mediaId)\n        }\n        catch (error) {\n            console.error(\"SeaDex: Error fetching records: \" + (error as Error).message)\n            return []\n        }\n\n        if (!records || records.length === 0) {\n            console.log(\"SeaDex: No records found for media ID \" + mediaId)\n            return []\n        }\n\n        const record = records[0]\n        if (!record.expand || !record.expand.trs || record.expand.trs.length === 0) {\n            console.log(\"SeaDex: Records found, but no torrents (expand.trs) attached.\")\n            return []\n        }\n\n        const torrents: SeaDexTorrent[] = []\n        for (const tr of record.expand.trs) {\n            if (!tr.infoHash || tr.infoHash === \"<redacted>\") continue\n            if (tr.tracker !== \"Nyaa\") continue\n            if (!tr.url || !tr.url.includes(\"nyaa.si\")) continue\n\n            const dualAudioTag = tr.dualAudio ? \" [Dual-Audio]\" : \"\"\n            const name = `[${tr.releaseGroup}] ${title}${dualAudioTag}`\n\n            const size = this.getTorrentSize(tr.files)\n\n            torrents.push({\n                name: name,\n                date: tr.created,\n                size: size,\n                link: tr.url,\n                infoHash: tr.infoHash,\n                releaseGroup: tr.releaseGroup,\n            })\n        }\n\n        return torrents\n    }\n\n    private async fetchRecords(mediaId: number): Promise<RecordItem[]> {\n        const uri = this.getUri()\n        const filter = encodeURIComponent(`alID=\"${mediaId}\"`)\n        const fullUrl = `${uri}?page=1&perPage=1&filter=${filter}&skipTotal=1&expand=trs`\n\n        console.log(\"SeaDex: Fetching from \" + fullUrl)\n\n        const res = await fetch(fullUrl)\n        if (!res.ok) {\n            throw new Error(`API request failed with status ${res.status}: ${res.statusText}`)\n        }\n\n        const data = await res.json() as RecordsResponse\n        return data.items || []\n    }\n\n    private getTorrentSize(files: TrFile[]): number {\n        if (!files || files.length === 0) {\n            return 0\n        }\n\n        return files.reduce((totalSize, file) => totalSize + file.length, 0)\n    }\n\n    private async toAnimeTorrent(t: SeaDexTorrent): Promise<AnimeTorrent> {\n        const ret: AnimeTorrent = {\n            name: t.name,\n            date: t.date,\n            size: t.size,\n            formattedSize: \"\",\n            seeders: -1,\n            leechers: 0,\n            downloadCount: 0,\n            link: t.link,\n            downloadUrl: \"\",\n            infoHash: t.infoHash,\n            magnetLink: \"\",\n            resolution: \"\",\n            isBatch: true,\n            episodeNumber: -1,\n            releaseGroup: t.releaseGroup || \"\",\n            isBestRelease: true,\n            confirmed: true,\n        }\n\n        try {\n            const res = await fetch(t.link, { timeout: 5000 })\n\n            if (res.ok) {\n                const html = await res.text()\n                const $ = LoadDoc(html)\n\n                const title = $(\"h3.panel-title\").text().trim()\n                if (title) {\n                    ret.name = title\n                }\n\n                let seeders = -1\n                let leechers = 0\n                let downloads = 0\n                let formattedSize = \"\"\n\n                $(\".panel-body .row div.col-md-1\").each((i, el) => {\n                    const text = el.text().trim()\n                    const valueEl = el.next()\n                    if (!valueEl) return\n\n                    const value = valueEl.text().trim()\n\n                    if (text === \"Seeders:\") {\n                        seeders = parseInt(value) || -1\n                    } else if (text === \"Leechers:\") {\n                        leechers = parseInt(value) || 0\n                    } else if (text === \"Downloads:\") {\n                        downloads = parseInt(value) || 0\n                    } else if (text === \"File size:\") {\n                        formattedSize = value\n                    }\n                })\n\n                ret.seeders = seeders\n                ret.leechers = leechers\n                ret.downloadCount = downloads\n                ret.formattedSize = formattedSize\n\n                ret.downloadUrl = $(\"a.card-footer-item[href*='/download/']\").attr(\"href\") || \"\"\n                if (ret.downloadUrl && !ret.downloadUrl.startsWith(\"http\")) {\n                    const url = new URL(t.link)\n                    ret.downloadUrl = `${url.protocol}//${url.host}${ret.downloadUrl}`\n                }\n            }\n        }\n        catch (e) {\n            console.warn(\"SeaDex: Failed to scrape Nyaa link for details: \" + (e as Error).message)\n        }\n\n        const metadata = $habari.parse(ret.name)\n        ret.resolution = metadata.video_resolution || \"\"\n        ret.releaseGroup = t.releaseGroup || metadata.release_group || \"\"\n\n        return ret\n    }\n}\n"
}
