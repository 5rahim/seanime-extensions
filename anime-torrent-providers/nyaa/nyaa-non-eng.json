{
  "id": "nyaa-non-eng",
  "name": "Nyaa (Non-English)",
  "description": "Nyaa provider for non-english torrents",
  "manifestURI": "https://raw.githubusercontent.com/5rahim/seanime-extensions/refs/heads/main/anime-torrent-providers/nyaa/nyaa.json",
  "version": "1.0.0",
  "author": "Seanime",
  "type": "anime-torrent-provider",
  "icon": "https://raw.githubusercontent.com/5rahim/hibike/main/icons/nyaa.png",
  "language": "typescript",
  "lang": "multi",
  "userConfig": {
    "requiresConfig": false,
    "version": 1,
    "fields": [
      {
        "name": "apiUrl",
        "label": "API URL",
        "type": "text",
        "default": "https://nyaa.si"
      },
      {
        "name": "category",
        "label": "Category",
        "type": "text",
        "default": "1_3"
      }
    ]
  },
  "payload": "/// <reference path=\"../anime-torrent-provider.d.ts\" />\n/// <reference path=\"../../core.d.ts\" />\n\ninterface ProviderConfig {\n    baseUrl: string;\n    category: string;\n}\n\ninterface RawTorrent {\n    name: string;\n    link: string; // GUID/Page URL\n    downloadUrl: string; // .torrent file URL\n    date: string; // raw date string\n    seeders: string;\n    leechers: string;\n    downloads: string;\n    infoHash: string;\n    size: string; // formatted size string\n}\n\nclass Provider {\n    canSmartSearch = true\n    supportsAdult = false\n\n    async getLatest(): Promise<AnimeTorrent[]> {\n        try {\n            const url = this.buildURL(\"\")\n            console.log(\"Nyaa: Fetching latest from \" + url)\n\n            const res = await fetch(url)\n            const rssText = await res.text()\n\n            const rawTorrents = this.parseRSSFeed(rssText)\n\n            const torrents = rawTorrents.map(t => this.toAnimeTorrent(t, \"nyaa\"))\n\n            console.log(`Nyaa: Found ${torrents.length} latest torrents`)\n            return torrents\n        }\n        catch (error) {\n            console.error(\"Nyaa: Error fetching latest: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    async search(options: AnimeSearchOptions): Promise<AnimeTorrent[]> {\n        try {\n            const url = this.buildURL(options.query)\n            console.log(\"Nyaa: Searching for \" + options.query)\n\n            const res = await fetch(url)\n            const rssText = await res.text()\n\n            const rawTorrents = this.parseRSSFeed(rssText)\n            const torrents = rawTorrents.map(t => this.toAnimeTorrent(t, \"nyaa\"))\n\n            console.log(`Nyaa: Found ${torrents.length} torrents for query`)\n            return torrents\n        }\n        catch (error) {\n            console.error(\"Nyaa: Error searching: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    async smartSearch(options: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {\n        try {\n            const queries = this.buildSmartSearchQueries(options)\n            if (!queries || queries.length === 0) {\n                console.warn(\"Nyaa: Smart search could not build queries\")\n                return []\n            }\n\n            console.log(\"Nyaa: Smart searching with queries: \" + JSON.stringify(queries))\n\n            const searchPromises = queries.map(async (query) => {\n                try {\n                    const url = this.buildURL(query)\n                    console.log(\"Nyaa: Smart search URL: \" + url)\n                    const res = await fetch(url)\n                    const rssText = await res.text()\n                    return this.parseRSSFeed(rssText)\n                }\n                catch (e) {\n                    console.error(\"Nyaa: Smart search sub-query failed: \" + (e as Error).message)\n                    return []\n                }\n            })\n\n            const results = await Promise.all(searchPromises)\n            const allRawTorrents = results.flat()\n\n            // Remove duplicates\n            const uniqueTorrentsMap = new Map<string, any>()\n            allRawTorrents.forEach(t => {\n                // Use downloadUrl (.torrent link) as unique key\n                if (t.downloadUrl && !uniqueTorrentsMap.has(t.downloadUrl)) {\n                    uniqueTorrentsMap.set(t.downloadUrl, t)\n                }\n            })\n\n            let torrents = [...uniqueTorrentsMap.values()].map(t => this.toAnimeTorrent(t, \"nyaa\"))\n            uniqueTorrentsMap.clear()\n\n            // Filter by episode number if not batch\n            if (!options.batch) {\n                torrents = torrents.filter(t => {\n                    const relEp = t.episodeNumber\n                    if (relEp === -1) return false\n\n                    const absEp = (options.media.absoluteSeasonOffset || 0) + options.episodeNumber\n\n                    return options.episodeNumber === relEp || absEp === relEp\n                })\n                console.log(`Nyaa: Filtered to ${torrents.length} torrents for episode ${options.episodeNumber}`)\n            }\n\n            return torrents\n\n        }\n        catch (error) {\n            console.error(\"Nyaa: Error in smart search: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    async getTorrentInfoHash(torrent: AnimeTorrent): Promise<string> {\n        return torrent.infoHash || \"\"\n    }\n\n    async getTorrentMagnetLink(torrent: AnimeTorrent): Promise<string> {\n        try {\n            const res = await fetch(torrent.link)\n            const html = await res.text()\n            const $ = LoadDoc(html)\n\n            let magnetLink = \"\"\n\n            // Search for the magnet link\n            $(\"a.card-footer-item, a[href^=\\\"magnet:\\\"]\").each((i: number, el) => {\n                const href = el.attr(\"href\")\n                if (href && href.startsWith(\"magnet:\")) {\n                    magnetLink = href\n                    return false // Break the loop\n                }\n            })\n\n            if (!magnetLink) {\n                throw new Error(\"Magnet link not found on page\")\n            }\n\n            return magnetLink\n        }\n        catch (error) {\n            console.error(\"Nyaa: Error fetching magnet link: \" + (error as Error).message)\n            throw new Error(\"Could not fetch magnet link for: \" + torrent.name)\n        }\n    }\n\n    getSettings(): AnimeProviderSettings {\n        return {\n            canSmartSearch: this.canSmartSearch,\n            smartSearchFilters: [\"batch\", \"episodeNumber\", \"resolution\", \"query\"],\n            supportsAdult: false,\n            type: \"main\",\n        }\n    }\n\n    private getProviderSettings(): ProviderConfig {\n        let url: string = $getUserPreference(\"apiUrl\") || \"nyaa.si\"\n        if (!url.startsWith(\"http\")) {\n            url = \"https://\" + url\n        }\n        return {\n            baseUrl: url.replace(/\\/$/, \"\"), // Remove trailing slash\n            category: $getUserPreference(\"category\") || \"1_2\",\n        }\n    }\n\n    private buildURL(query: string, sortBy: string = \"seeders\"): string {\n        const { baseUrl, category } = this.getProviderSettings()\n\n        const queryString = `page=rss&q=${encodeURIComponent(query)}&c=${category}&f=0&s=${sortBy}&o=desc`\n        return `${baseUrl}/?${queryString}`\n    }\n\n    private parseRSSFeed(rssText: string): RawTorrent[] {\n        const torrents: RawTorrent[] = []\n\n        // Helper to extract content between XML tags\n        const getTagContent = (xml: string, tag: string): string => {\n            const regex = new RegExp(`<${tag}[^>]*>([^<]*)</${tag}>`)\n            const match = xml.match(regex)\n            return match ? match[1].trim() : \"\"\n        }\n\n        // Helper to extract content from nyaa namespace tags\n        const getNyaaTagContent = (xml: string, tag: string): string => {\n            const regex = new RegExp(`<nyaa:${tag}[^>]*>([^<]*)</nyaa:${tag}>`)\n            const match = xml.match(regex)\n            return match ? match[1].trim() : \"\"\n        }\n\n        // Split XML into items\n        const itemRegex = /<item>([\\s\\S]*?)<\\/item>/g\n        let match\n\n        while ((match = itemRegex.exec(rssText)) !== null) {\n            const itemXml = match[1]\n\n            const title = getTagContent(itemXml, \"title\")\n            const downloadUrl = getTagContent(itemXml, \"link\") // .torrent file URL\n            const link = getTagContent(itemXml, \"guid\")      // Page URL\n            const pubDate = getTagContent(itemXml, \"pubDate\")\n            const seeders = getNyaaTagContent(itemXml, \"seeders\")\n            const leechers = getNyaaTagContent(itemXml, \"leechers\")\n            const downloads = getNyaaTagContent(itemXml, \"downloads\")\n            const infoHash = getNyaaTagContent(itemXml, \"infoHash\")\n            const size = getNyaaTagContent(itemXml, \"size\")\n\n            const torrent: RawTorrent = {\n                name: title,\n                link: link,\n                downloadUrl: downloadUrl,\n                date: pubDate,\n                seeders: seeders,\n                leechers: leechers,\n                downloads: downloads,\n                infoHash: infoHash,\n                size: size,\n            }\n\n            torrents.push(torrent)\n        }\n\n        return torrents\n    }\n\n    private toAnimeTorrent(t: RawTorrent, providerName: string): AnimeTorrent {\n        const metadata = $habari.parse(t.name)\n\n        const seeders = parseInt(t.seeders) || 0\n        const leechers = parseInt(t.leechers) || 0\n        const downloads = parseInt(t.downloads) || 0\n\n        let formattedDate = \"\"\n        try {\n            const parsedDate = new Date(t.date)\n            if (!isNaN(parsedDate.getTime())) {\n                formattedDate = parsedDate.toISOString()\n            }\n        }\n        catch (e) {\n            console.warn(\"Nyaa: Failed to parse date: \" + t.date)\n        }\n\n        let sizeInBytes = 0\n        const sizeMatch = t.size.match(/([\\d.]+)\\s*([KMGT]?i?B)/i)\n        if (sizeMatch) {\n            const size = parseFloat(sizeMatch[1])\n            const unit = sizeMatch[2].toUpperCase()\n            if (unit.endsWith(\"IB\")) {\n                if (unit.startsWith(\"M\")) sizeInBytes = size * Math.pow(1024, 2)\n                else if (unit.startsWith(\"G\")) sizeInBytes = size * Math.pow(1024, 3)\n                else if (unit.startsWith(\"T\")) sizeInBytes = size * Math.pow(1024, 4)\n                else sizeInBytes = size * 1024\n            } else {\n                if (unit.startsWith(\"M\")) sizeInBytes = size * Math.pow(1000, 2)\n                else if (unit.startsWith(\"G\")) sizeInBytes = size * Math.pow(1000, 3)\n                else if (unit.startsWith(\"T\")) sizeInBytes = size * Math.pow(1000, 4)\n                else sizeInBytes = size * 1000\n            }\n        }\n\n        let episode = -1\n        if (metadata.episode_number && metadata.episode_number.length >= 1) {\n            episode = parseInt(metadata.episode_number[0]) || -1\n        }\n\n        let isBatchByGuess = false\n        if (metadata.episode_number && metadata.episode_number.length > 1) {\n            isBatchByGuess = true\n        }\n        if (/\\b(batch|complete|collection|seasons?|parts?)\\b/i.test(t.name)) {\n            isBatchByGuess = true\n        }\n\n        if (isBatchByGuess) {\n            episode = -1\n        }\n\n        return {\n            name: t.name,\n            date: formattedDate,\n            size: Math.round(sizeInBytes),\n            formattedSize: t.size,\n            seeders: seeders,\n            leechers: leechers,\n            downloadCount: downloads,\n            link: t.link,\n            downloadUrl: t.downloadUrl,\n            infoHash: t.infoHash,\n            magnetLink: \"\",\n            resolution: metadata.video_resolution || \"\",\n            isBatch: isBatchByGuess,\n            episodeNumber: episode,\n            releaseGroup: metadata.release_group || \"\",\n            isBestRelease: false,\n            confirmed: false,\n        }\n    }\n\n    private buildSmartSearchQueries(opts: AnimeSmartSearchOptions): string[] {\n        const { media, query: userQuery, batch, episodeNumber, resolution } = opts\n\n        let romTitle = media.romajiTitle || \"\"\n        let engTitle = media.englishTitle || \"\"\n        let allTitles = [romTitle, engTitle, ...(media.synonyms || [])].filter(Boolean)\n\n        let season = 0\n        let part = 0\n        let titles: string[] = []\n\n        if (!userQuery) {\n            allTitles.forEach(title => {\n                let s: number, p: number, cTitle: string;\n                [s, cTitle] = this.extractSeasonNumber(title);\n                [p, cTitle] = this.extractPartNumber(cTitle)\n                if (s !== 0) season = s\n                if (p !== 0) part = p\n                if (cTitle) titles.push(cTitle)\n            })\n\n            if (season === 0) {\n                (media.synonyms || []).forEach(synonym => {\n                    const [s, _] = this.extractSeasonNumber(synonym)\n                    if (s !== 0) season = s\n                })\n            }\n\n            if (season === 0 && part === 0 && titles.length === 0) {\n                if (romTitle) titles.push(romTitle)\n                if (engTitle) titles.push(engTitle)\n            }\n\n            [romTitle, engTitle].filter(Boolean).forEach(title => {\n                const split = title.split(\":\")\n                if (split.length > 1 && split[0].length > 8) {\n                    titles.push(split[0])\n                }\n            })\n\n            if (season === 0) {\n                if (/\\biii\\b/i.test(romTitle) || (engTitle && /\\biii\\b/i.test(engTitle))) season = 3\n                else if (/\\bii\\b/i.test(romTitle) || (engTitle && /\\bii\\b/i.test(engTitle))) season = 2\n            }\n\n            titles = titles.map(t => {\n                let clean = t.replace(/:/g, \" \").replace(/-/g, \" \").trim()\n                clean = clean.replace(/\\s+/g, \" \")\n                clean = clean.toLowerCase()\n                if (season !== 0) {\n                    clean = clean.replace(/\\biii\\b/gi, \"\").replace(/\\bii\\b/gi, \"\")\n                }\n                return clean.trim()\n            })\n\n            titles = [...new Set(titles.filter(Boolean))]\n\n        } else {\n            titles = [userQuery.toLowerCase()]\n        }\n\n        if (titles.length === 0) {\n            return []\n        }\n\n        const canBatch = media.status === \"FINISHED\" && (media.episodeCount || 0) > 0\n        let normalBuff = \"\"\n        let batchBuff = \"\"\n\n        // Parameters\n        if (batch && canBatch && !(media.format === \"MOVIE\" && (media.episodeCount || 0) === 1)) {\n            if (season !== 0) batchBuff += this.buildSeasonString(season)\n            if (part !== 0) batchBuff += this.buildPartString(part)\n            batchBuff += this.buildBatchString(media)\n        } else {\n            normalBuff += this.buildSeasonString(season)\n            if (part !== 0) normalBuff += this.buildPartString(part)\n            if (!(media.format === \"MOVIE\" && (media.episodeCount || 0) === 1)) {\n                normalBuff += this.buildEpisodeString(episodeNumber)\n            }\n        }\n\n        let titleStr = this.buildTitleString(titles)\n        if (userQuery) {\n            titleStr = `(${userQuery})`\n        }\n\n        const batchStr = batchBuff\n        const normalStr = normalBuff\n\n        let query = `${titleStr}${batchStr}${normalStr}`\n\n        // Resolution part\n        const resStr = resolution ? `(${resolution})` : \"(360|480|720|1080)\"\n        query += resStr\n\n        const queries = [query]\n\n        // Absolute episode addition\n        if (!batch && (media.absoluteSeasonOffset || 0) > 0 && !(media.format === \"MOVIE\" && (media.episodeCount || 0) === 1)) {\n            const absEp = episodeNumber + (media.absoluteSeasonOffset || 0)\n            const query2 = `${titleStr}(${absEp})${resStr}`\n            queries.push(query2)\n        }\n\n        return queries\n    }\n\n    private zeropad(v: number): string {\n        const s = String(v)\n        return s.length < 2 ? \"0\" + s : s\n    }\n\n    private buildTitleString(titles: string[]): string {\n        if (titles.length === 1) {\n            return `(${titles[0]})`\n        }\n        const quotedTitles = titles.map(t => `\"${t}\"`)\n        return `(${quotedTitles.join(\"|\")})`\n    }\n\n    private buildEpisodeString(ep: number): string {\n        const pEp = this.zeropad(ep)\n        return `(${pEp}|e${pEp}|e${pEp}v|${pEp}v|ep${pEp}|ep${ep})`\n    }\n\n    private buildSeasonString(season: number): string {\n        if (season === 0) return \"\"\n        const pS = this.zeropad(season)\n        return `(\"season ${season}\"|\"season ${pS}\"|\"s${season}\"|\"s${pS}\")`\n    }\n\n    private buildPartString(part: number): string {\n        if (part === 0) return \"\"\n        return `(\"part ${part}\")`\n    }\n\n    private buildBatchString(media: AnimeSmartSearchOptions[\"media\"]): string {\n        const epCount = this.zeropad(media.episodeCount || 0)\n        const parts = [\n            `\"01 - ${epCount}\"`,\n            `\"01 ~ ${epCount}\"`,\n            `\"Batch\"`,\n            `\"Complete\"`,\n            `\"+ OVA\"`,\n            `\"+ Specials\"`,\n            `\"+ Special\"`,\n            `\"Seasons\"`,\n            `\"Parts\"`,\n        ]\n        return `(${parts.join(\"|\")})`\n    }\n\n    private extractSeasonNumber(title: string): [number, string] {\n        const match = title.match(/\\b(season|s)\\s*(\\d{1,2})\\b/i)\n        if (match && match[2]) {\n            const cleanTitle = title.replace(match[0], \"\").trim()\n            return [parseInt(match[2]), cleanTitle]\n        }\n        return [0, title]\n    }\n\n    private extractPartNumber(title: string): [number, string] {\n        const match = title.match(/\\b(part|p)\\s*(\\d{1.2})\\b/i)\n        if (match && match[2]) {\n            const cleanTitle = title.replace(match[0], \"\").trim()\n            return [parseInt(match[2]), cleanTitle]\n        }\n        return [0, title]\n    }\n\n}\n"
}
